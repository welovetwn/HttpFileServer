# HttpFileServer 專案改善建議  
> 分析者角色：.NET Core / C# 資深工程師  
> 專案來源：[https://github.com/welovetwn/HttpFileServer](https://github.com/welovetwn/HttpFileServer)  

---

## ⛳ 初步發現的問題與風險  

| 類別 | 問題或風險 | 說明 / 潛在影響 |
|------|------------|----------------|
| **認證 / 密碼儲存** | 密碼以明文儲存 | 極高風險，應使用雜湊儲存 |
| **通訊安全** | 無 HTTPS 支援 | 傳輸中可能被竊聽 |
| **授權控制** | 權限以字串/數字控制 | 權限控制不夠嚴謹，無使用 ASP.NET Core 授權策略 |
| **路徑安全** | 可能發生 Path Traversal | 用戶可跳脫目錄限制讀取系統檔 |
| **錯誤處理** | 例外資訊暴露 | 可能回傳 Stack Trace 給前端，造成資訊洩漏 |
| **設定檔存取** | JSON 同步存取可能競爭 | 多人同時編輯可能損毀設定檔 |
| **控制介面** | API 可關機/重啟服務 | 安全風險高，應嚴格限制與記錄 |
| **測試機制** | 無單元/整合測試 | 難以驗證變更是否影響功能 |
| **模組耦合** | 控制器與邏輯混雜 | 維護與擴充困難 |

---

## ✅ 重構與改善建議  

### 1️⃣ 密碼安全（強制雜湊）

- 使用 `PasswordHasher<T>` 或 bcrypt/Argon2 實作雜湊。
- 密碼儲存格式應包含鹽（Salt）與演算法版本。

### 2️⃣ HTTPS 支援

- 在 `appsettings.json` 或 Kestrel 中設定 HTTPS 憑證。
- 或於部署時透過 Nginx / Apache 反向代理處理 TLS。

### 3️⃣ 授權機制強化

- 改為基於 Claims 的 Policy 授權。
- 權限角色與帳號資料解耦，允許彈性管理。
- 管理 API 僅允許特定角色呼叫，並加上日誌。

### 4️⃣ 防止路徑穿越

- 所有檔案路徑需經過標準化與驗證。
- 使用 `Path.GetFullPath()` 後檢查是否仍在允許根目錄下。

### 5️⃣ 統一例外處理

- 加入 ASP.NET Core Middleware 處理全域錯誤。
- 記錄 Log，回傳簡化訊息給前端，防止敏感資訊外洩。

### 6️⃣ 設定檔安全更新

- 加入鎖（Lock）或使用 `ReaderWriterLockSlim` 保護 JSON 寫入。
- 或使用資料庫（如 LiteDB）取代 JSON 存儲。

### 7️⃣ 分層架構（Controller / Service / Repository）

- 控制器只負責接收與回應。
- 商業邏輯應集中在 Service 層。
- 資料存取應獨立為 Repository。

### 8️⃣ 加入單元與整合測試

- 為核心邏輯如密碼驗證、授權邏輯撰寫測試。
- 使用 xUnit + WebApplicationFactory 模擬 API 呼叫流程。

### 9️⃣ 操作審計與日誌

- 所有重要管理操作都要紀錄審計資訊（帳號、IP、時間、操作類型）。
- 使用 Serilog / NLog 進行日誌管理與查詢。

### 🔟 加入防禦式設計

- 對 API 加入請求頻率限制（Rate Limiting）。
- 使用 Anti-forgery Token 防止 CSRF 攻擊（若為 Web UI）。
- 所有 API 的參數驗證需嚴謹處理，避免輸入注入。

---

## 🧪 範例：安全的密碼驗證與建立

```csharp
// Services/UserService.cs
using Microsoft.AspNetCore.Identity;

public class UserService
{
    private readonly IUserStore _store;

    public UserService(IUserStore store)
    {
        _store = store;
    }

    public void CreateUser(string username, string password)
    {
        var hasher = new PasswordHasher<string>();
        var hash = hasher.HashPassword(username, password);

        var user = new User
        {
            Username = username,
            PasswordHash = hash
        };

        _store.Save(user);
    }

    public bool ValidateLogin(string username, string password)
    {
        var user = _store.Get(username);
        if (user == null) return false;

        var hasher = new PasswordHasher<string>();
        var result = hasher.VerifyHashedPassword(username, user.PasswordHash, password);

        return result == PasswordVerificationResult.Success;
    }
}
```
---

## 🧩 建議後續重構路徑

1. 設計密碼安全模組
2. 導入授權中介軟體
3. 將所有服務模組化
4. 增加測試與部署流程
5. 設計操作日誌與錯誤通知系統

---

## 📌 備註

此改善報告為根據公開版本所寫（2025-10）。若你有內部修改版本，建議重新分析一次以確保精準改善。

```